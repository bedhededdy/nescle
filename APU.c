/*
 * Copyright 2023 Edward C. Pinkston
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// TODO: CHANGE VSCODE TO USE ALT+ENTER FOR COPILOT INSTEAD OF CTRL+ENTER
#include "APU.h"
#include <stdlib.h>
#include <math.h>
#include <stdio.h>

// normal sin is too slow, so we use this approximation to speed up the
// emulation
double fast_sin(double x) {
    double j = x * 0.15915;
    j = j - (int)j;
    return 20.785 * j * (j - 0.5) * (j - 1.0);
}

double oscpulse_sample(APU_PulseWave* pulse, double t) {
    double a = 0;
    double b = 0;
    double p = pulse->duty_cycle * 2.0 * 3.14159;

    for (double n = 1; n < pulse->harmonics; n++) {
       double c = n * pulse->freq * 2.0 * 3.14159 * t;
       a += -fast_sin(c) / n;
       b += -fast_sin(c - p * n ) / n;
    }

    return (2.0 * pulse->amplitude / 3.14159) * (a - b);
   //  double d = sin(2.0 * 3.14159 * pulse->freq * t);
   //  if (d >= 0.0)
   //      return 1.0;
   //  else
   //      return -1.0;
}

double osctriangle_sample(APU_TriangleWave* osctriangle, double t) {
    // Triangle wave is generated by the formula
    // 2/pi * arcsin(sin(2pi * ft))
    return 2.0 / 3.14159 * asin(sin(2.0 * 3.14159 * osctriangle->freq * t));
}

bool APU_Write(APU* apu, uint16_t addr, uint8_t data) {
    switch (addr) {
    case 0x4000:
        switch ((data & 0xc0) >> 6) {
            // set the different kinds of pulse waves
            // eighth, quarter, half, and three quarter
            case 0: apu->pulse1.sequencer.sequence = 1; apu->pulse1.wave.duty_cycle = 0.125;   break;
            case 1: apu->pulse1.sequencer.sequence = 2;    apu->pulse1.wave.duty_cycle = 0.25;    break;
            case 2: apu->pulse1.sequencer.sequence = 0xf;  apu->pulse1.wave.duty_cycle = 0.500; break;
            case 3: apu->pulse1.sequencer.sequence = 0xfc; apu->pulse1.wave.duty_cycle = 0.75; break;
        }
        break;
    case 0x4002:
        apu->pulse1.sequencer.reload = (apu->pulse1.sequencer.reload & 0xff00) | data;
        break;
    case 0x4003:
        apu->pulse1.sequencer.reload = (uint16_t)((data & 7)) << 8 | (apu->pulse1.sequencer.reload & 0x00ff);
        apu->pulse1.sequencer.timer = apu->pulse1.sequencer.reload;
        break;

    case 0x4004:
        switch ((data & 0xc0) >> 6) {
        case 0:
            apu->pulse2.sequencer.sequence = 1;
            apu->pulse2.wave.duty_cycle = 0.125;
            break;
        case 1:
            apu->pulse2.sequencer.sequence = 2;
            apu->pulse2.wave.duty_cycle = 0.25;
            break;
        case 2:
            apu->pulse2.sequencer.sequence = 0xf;
            apu->pulse2.wave.duty_cycle = 0.500;
            break;
        case 3:
            apu->pulse2.sequencer.sequence = 0xfc;
            apu->pulse2.wave.duty_cycle = 0.75;
            break;
        }
        break;
    case 0x4006:
        apu->pulse2.sequencer.reload = (apu->pulse2.sequencer.reload & 0xff00) | data;
        break;
    case 0x4007:
        apu->pulse2.sequencer.reload = (uint16_t)((data & 7)) << 8 | (apu->pulse2.sequencer.reload & 0x00ff);
        apu->pulse2.sequencer.timer = apu->pulse2.sequencer.reload;

    case 0x4008:
        break;
    case 0x4009:
        break;
    case 0x400a:
        apu->triangle.sequencer.reload = (apu->triangle.sequencer.reload & 0xff00) | data;
        break;
    case 0x400b:
        // FIXME: ANDING OUT THE TOP BIT MIGHT NOT BE RIGHT
        // AND SHOULD MAYBE BE IN THE 0X4008 CASE
        apu->triangle.sequencer.reload = (uint16_t)((data & 7)) << 8
            | (apu->triangle.sequencer.reload & 0x00ff);
        apu->triangle.sequencer.timer = apu->triangle.sequencer.reload;
        break;

    case 0x4015:
        apu->pulse1.enable = data & 1;
        apu->pulse2.enable = data & 2;
        // FIXME: I DON'T CONFIRM THE FOLLOWING IS CORRECT
        apu->triangle.enable = data & 4;
        break;

    case 0x4017:
        // Frame counter
        // TODO: IMPLEMENT
        break;
    }

    return true;
}

uint8_t APU_Read(APU* apu, uint16_t addr) {
    return 0;
}

static void pulse1_clock(uint32_t* seq_ptr) {
    // Rotate the bits right by 1
    *seq_ptr = ((*seq_ptr & 1) << 7) | ((*seq_ptr & 0xfe) >> 1);
}

void APU_SequencerClock2(APU *apu, bool enable, void (*func)(uint32_t *))
{
    if (enable)
    {
        apu->pulse2.sequencer.timer--;
        if (apu->pulse2.sequencer.timer == 0xffff)
        {
            apu->pulse2.sequencer.timer = apu->pulse2.sequencer.reload + 1;
            func(&apu->pulse2.sequencer.sequence);
            apu->pulse2.sequencer.output = apu->pulse2.sequencer.sequence & 1;
        }
    }
}

void APU_Clock(APU* apu) {
    bool quarter_frame = false;
    bool half_frame = false;

    apu->global_time += (0.3333333333333 / 1789773);
    // apu->global_time += 1.0/44100;

    // APU although clocking each time with the PPU, runs at half the CPU
    // clock, which is 1/3 of the PPU clock
    if (apu->clock_count % 6 == 0) {
        apu->frame_clock_count++;

        // 4-Step Sequence mode
        if (apu->frame_clock_count == 3729)
            quarter_frame = true;
        if (apu->frame_clock_count == 7457)
            quarter_frame = half_frame = true;
        if (apu->frame_clock_count == 11186)
            quarter_frame = true;
        if (apu->frame_clock_count == 14916) {
            quarter_frame = true;
            half_frame = true;
            apu->frame_clock_count = 0;
        }

        // TODO: IMPLEMENT 2-Step Sequence mode
        if (quarter_frame) {
            // "beats" adjust the volume envelope
        }

        if (half_frame) {
            // adjust note length and frequency sweepers
        }

        // update sequencers

        // bad sound, good performance
        // APU_SequencerClock(apu, apu->pulse1->enable, &pulse1_clock);
        // apu->pulse1->sample = (double)apu->sequencer->output;
        // APU_SequencerClock2(apu, apu->pulse2->enable, &pulse1_clock);
        // apu->pulse2->sample = (double)apu->sequencer2->output;

        // TODO: SPEED THIS UP AS MUCH AS POSSIBLE, CONSIDER REDUCING
        // NUMBER OF HARMONICS
        // ALSO CONSIDER JUST DOING THE FLAT SQUARE WAVE WITH MAYBE LIKE A
        // SMOOTHING EFFECT AT THE EDGE
        // apu->pulse1.wave.harmonics = 30;
        // apu->pulse2.wave.harmonics = 30;

        apu->pulse1.wave.freq = 1789773.0 / (16.0 * (double)(apu->pulse1.sequencer.reload + 1));
        apu->pulse1.sample = oscpulse_sample(&apu->pulse1.wave, apu->global_time);
        apu->pulse2.wave.freq = 1789773.0 / (16.0 * (double)(apu->pulse2.sequencer.reload + 1));
        apu->pulse2.sample = oscpulse_sample(&apu->pulse2.wave, apu->global_time);

        // TRIANGLE WAVE IS AN OCTAVE LOWER SO DIVIDE THE OUTPUT
        // BY 2
        apu->triangle.wave.freq = 1789773.0 / (16.0 * (double)(apu->triangle.sequencer.reload + 1)) / 2;
        apu->triangle.sample = osctriangle_sample(&apu->triangle.wave, apu->global_time);

        // Mute super high frequencies to save the children's ears until I fix
        // the emulation
        if (apu->pulse1.wave.freq > 8000)
            apu->pulse1.sample = 0;
        if (apu->pulse2.wave.freq > 8000)
            apu->pulse2.sample = 0;
        if (apu->triangle.wave.freq > 8000)
            apu->triangle.sample = 0;
    }

    apu->clock_count++;
}

void APU_Reset(APU* apu) {
    apu->clock_count = 0;
    apu->global_time = 0;

    apu->pulse1.sequencer.sequence = 0;
    apu->pulse1.sequencer.timer = 0;
    apu->pulse1.sequencer.reload = 0;
    apu->pulse1.sequencer.output = 0;
    apu->pulse1.wave.freq = 0;
    apu->pulse1.wave.amplitude = 1;
    apu->pulse1.wave.duty_cycle = 0;
    apu->pulse1.wave.harmonics = 20;

    apu->pulse2.sequencer.sequence = 0;
    apu->pulse2.sequencer.timer = 0;
    apu->pulse2.sequencer.reload = 0;
    apu->pulse2.sequencer.output = 0;
    apu->pulse2.wave.freq = 0;
    apu->pulse2.wave.duty_cycle = 0;
    apu->pulse2.wave.amplitude = 1;
    apu->pulse2.wave.harmonics = 20;

    apu->triangle.sequencer.output = 0;
    apu->triangle.sequencer.timer = 0;
    apu->triangle.sequencer.reload = 0;
    apu->triangle.sequencer.sequence = 0;
    apu->triangle.wave.freq = 0;
    apu->triangle.wave.amplitude = 1;
    apu->triangle.wave.harmonics = 20;
}

void APU_PowerOn(APU* apu) {
    apu->clock_count = 0;
    apu->global_time = 0;

    apu->pulse1.sequencer.sequence = 0;
    apu->pulse1.sequencer.timer = 0;
    apu->pulse1.sequencer.reload = 0;
    apu->pulse1.sequencer.output = 0;
    apu->pulse1.wave.freq = 0;
    apu->pulse1.wave.amplitude = 1;
    apu->pulse1.wave.duty_cycle = 0;
    apu->pulse1.wave.harmonics = 20;

    apu->pulse2.sequencer.sequence = 0;
    apu->pulse2.sequencer.timer = 0;
    apu->pulse2.sequencer.reload = 0;
    apu->pulse2.sequencer.output = 0;
    apu->pulse2.wave.freq = 0;
    apu->pulse2.wave.duty_cycle = 0;
    apu->pulse2.wave.amplitude = 1;
    apu->pulse2.wave.harmonics = 20;

    apu->triangle.sequencer.output = 0;
    apu->triangle.sequencer.timer = 0;
    apu->triangle.sequencer.reload = 0;
    apu->triangle.sequencer.sequence = 0;
    apu->triangle.wave.freq = 0;
    apu->triangle.wave.amplitude = 1;
    apu->triangle.wave.harmonics = 20;
}

void APU_SequencerClock(APU* apu, bool enable, void (*func)(uint32_t*)) {
    if (enable) {
        apu->pulse1.sequencer.timer--;
        if (apu->pulse1.sequencer.timer == 0xffff) {
            apu->pulse1.sequencer.timer = apu->pulse1.sequencer.reload + 1;
            func(&apu->pulse1.sequencer.sequence);
            apu->pulse1.sequencer.output = apu->pulse1.sequencer.sequence & 1;
        }
    }
}

APU* APU_Create(void) {
    APU* apu = malloc(sizeof(APU));
    return apu;
}

void APU_Destroy(APU* apu) {
    free(apu);
}

double APU_GetOutputSample(APU* apu) {
    return apu->pulse1.sample + apu->pulse2.sample + apu->triangle.sample;
}
